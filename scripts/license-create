#!/usr/bin/env python
import sys
sys.path.append('/opt/palette')

from datetime import datetime
from dateutil.relativedelta import relativedelta
from webob import exc
import uuid
import urllib
import logging

from akiri.framework import GenericWSGIApplication
from akiri.framework.route import Router
from akiri.framework.middleware.sqlalchemy import SessionMiddleware
from akiri.framework.sqlalchemy import create_engine, get_session
from akiri.framework.util import required_parameters

from stage import Stage
from licensing import License
from system import System
from product import Product
from support import Support
from utils import get_netloc, hostname_only, domain_only
from salesforce_api import SalesforceAPI
from sendwithus_api import SendwithusAPI
from slack_api import SlackAPI
from ansible_api import AnsibleAPI
from boto_api import BotoAPI

DATABASE = 'postgresql://palette:palpass@localhost/licensedb'

def time_from_today(hours=0, days=0, months=0):
    return datetime.utcnow() + \
           relativedelta(hours=hours, days=days, months=months)

def kvp(key, value):
    if value is not None:
        return str(key) + '=' + urllib.quote(str(value))
    else:
        return str(key) + '='

def dict_to_qs(data):
    qstr = '&'.join([kvp(k, v) for k, v in data.iteritems()])
    if not qstr:
        return ''
    return '?' + qstr

def translate_values(source, entry, fields):
    """Convert fields values to the appropriate values in the entry."""
    for name, dest_attr in fields.items():
        value = source.get(name)
        if value is not None:
            setattr(entry, dest_attr, value)

def get_unique_name(name):
    """ Lookup and get a unique name for the server based on
        what is already in the database
        The algorithm comes up with names in this format:
        foo, foo-2, foo-3
    """
    count = 2
    to_try = name

    while True:
        result = License.get_by_name(to_try)
        if result is not None:
            # name exists try the next numbered one$
            to_try = '{0}-{1}'.format(name, count)
            count = count + 1
        else:
            break

    return to_try

def populate_email_data(entry):
    """ creates a dict that contains the fileds to put passed to trial emails
    """
    email_data = {'license':entry.key,
                  'firstname':entry.firstname,
                  'lastname':entry.lastname,
                  'email':entry.email,
                  'organization':entry.organization,
                  'hosting_type':entry.hosting_type,
                  'promo_code':entry.promo_code,
                  'subdomain':entry.subdomain,
                  'access_key':entry.access_key,
                  'secret_key':entry.secret_key}
    return email_data

def populate_buy_email_data(entry):
    """ creates a dict that contains the fileds to put passed to buy emails
    """
    email_data = {'firstname':entry.firstname,
                  'lastname':entry.lastname,
                  'email':entry.email,
                  'phone':entry.phone,
                  'org':entry.organization,
                  'hosting_type':entry.hosting_type,
                  'billing_address_line1':entry.billing_address_line1,
                  'billing_address_line2':entry.billing_address_line2,
                  'billing_city':entry.billing_city,
                  'billing_state':entry.billing_state,
                  'billing_zip':entry.billing_zip,
                  'billing_country':entry.billing_country}
    return email_data

REGISTER_FIELDS = {
        'firstname':'firstname',
        'lastname':'lastname',
        'email':'email',
        'name':'name'
}
class LicenseAPI():
    def new_license(self, params):
        """ Handle licensing for a new user 
        """
        session = get_session()
        print params['name']
        entry = License.get_by_name(params['name'])
        if entry is not None:
            logger.info('License already exists for %s %s %s %s',
                  entry.name, entry.firstname, entry.lastname, entry.email)
            return
        else:
            entry = License()
            translate_values(params, entry, REGISTER_FIELDS)
            logger.info('Generating new license for %s %s %s',
                        entry.firstname, entry.lastname, entry.email)

            entry.key = str(uuid.uuid4())
            entry.stageid = Stage.get_by_key('STAGE-CLOSED-WON').id
            entry.registration_start_time = datetime.utcnow()
            entry.expiration_time = time_from_today(months=12)
            entry.organization = get_netloc(domain_only(entry.email)).lower()
            entry.website = entry.organization
            entry.subdomain = params['name'] 
            entry.name = entry.subdomain
            entry.productid = Product.get_by_key('PALETTE-ENT').id
            entry.salesforceid = SalesforceAPI.new_opportunity(entry)
            session.add(entry)
            session.commit()

            # notify slack
            sf_url = '{0}/{1}'.format(SalesforceAPI.get_url(),
                                      entry.salesforceid)
            SlackAPI.notify('*{0}* Generated New License for: '
                    '{1} ({2}) {3}'.format(
                    Stage.get_stage_name(entry.stageid),
                    SalesforceAPI.get_opportunity_name(entry),
                    entry.email,
                    sf_url))

            # subscribe the user to the trial workflow if not already
            SendwithusAPI.subscribe_user(
                      System.get_by_key('SENDWITHUS-CLOSED-WON-ID'),
                      'hello@palette-software.com',
                      entry.email,
                      populate_email_data(entry))

            #SendwithusAPI.send_message(
            #              System.get_by_key('SENDWITHUS-BUY-NOTIFICATION-ID'),
            #              'licensing@palette-software.com',
            #              'hello@palette-software.com',
            #               populate_email_data(entry))

            logger.info('Generated new License Name {0} Key {1} success.'\
                       .format(entry.name, entry.key))


# pylint: disable=invalid-name
database = DATABASE
create_engine(database, echo=False, pool_size=20, max_overflow=30)

# Setup logging
logger = logging.getLogger('licensing')
logger.setLevel(logging.DEBUG)
ch = logging.StreamHandler()
ch.setLevel(logging.INFO)
formatter = logging.Formatter(\
                    '%(asctime)s - %(name)s - %(levelname)s - %(message)s')
ch.setFormatter(formatter)
logger.addHandler(ch)


if __name__ == '__main__':
    import argparse
    from akiri.framework.server import runserver
    from paste.translogger import TransLogger

    parser = argparse.ArgumentParser()
    parser.add_argument('--fullname', required=True) 
    parser.add_argument('--name', required=True) 
    parser.add_argument('--email', required=True)
    args = parser.parse_args()

    parts = args.fullname.split(' ')
    fn = parts[0]
    ln = parts[1]
 
    app = LicenseAPI()
    data = {'firstname':fn, 
            'lastname':ln,
            'email':args.email,
            'name':args.name}
    app.new_license(data)
